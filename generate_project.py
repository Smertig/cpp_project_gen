import pathlib
import shutil
import os
import json
import subprocess
import argparse
import sys
import time

parser = argparse.ArgumentParser(description="Project generator")

parser.add_argument("--project-model", type=str, choices=['cmake', 'compdb'], default='cmake',
                    help="project model to use, 'cmake' or 'compdb' ('cmake' by default)")
parser.add_argument("--compiler", type=str, help="path to the compiler")
parser.add_argument("--sources", type=int, default=50000, help="number of source files (50000 by default)")
parser.add_argument("--headers", type=int, default=10000, help="number of header files (10000 by default)")
parser.add_argument("--subdirs", type=int, default=250, help="number of sub-directories (250 by default)")
parser.add_argument("--header-lines", type=int, default=1000, help="number of lines in each header (1000 by default)")
parser.add_argument("--output", type=str, default=None, help="output directory ('.' by default)")
parser.add_argument("--name", type=str, default=None, help="project name (auto-generated by default)")

args = parser.parse_args()

COMPILER_PATH = args.compiler
PROJECT_MODEL = args.project_model
NUMBER_OF_SOURCES = args.sources
NUMBER_OF_HEADERS = args.headers
SUBDIR_COUNT = args.subdirs
NUMBER_OF_LINES_IN_HEADER = args.header_lines
OUTPUT_DIR = pathlib.Path(args.output) if args.output is not None else pathlib.Path.cwd()
PROJECT_NAME = args.name or f"BigProject_{NUMBER_OF_SOURCES}_{NUMBER_OF_HEADERS}"

# Validation
if PROJECT_MODEL == 'compdb' and COMPILER_PATH is None:
    parser.error("Compiler path is required when using compdb project model")
elif COMPILER_PATH is not None and not os.path.isfile(COMPILER_PATH):
    parser.error(f"No compiler at {COMPILER_PATH}")

SOURCES_PER_DIR = (NUMBER_OF_SOURCES + SUBDIR_COUNT - 1) // SUBDIR_COUNT
HEADERS_PER_DIR = (NUMBER_OF_HEADERS + SUBDIR_COUNT - 1) // SUBDIR_COUNT

PROJECT_DIR = OUTPUT_DIR / PROJECT_NAME
SOURCES_DIR = PROJECT_DIR / "sources"
INCLUDES_DIR = PROJECT_DIR / "includes"


class ProgressReporter:
    def __init__(self, interval=5):
        self._last_report = time.time()
        self._interval = interval

    def report(self, msg: str):
        now = time.time()
        if now - self._last_report > self._interval:
            print(msg)
            self._last_report = now


def get_source_subdir(i: int) -> str:
    return f"subdir_{i // SOURCES_PER_DIR}"


def get_include_subdir(i: int) -> str:
    return f"subdir_{i // HEADERS_PER_DIR}"


def get_source_template(i: int) -> str:
    header_i = i % NUMBER_OF_HEADERS

    return f"""
#include <file_{header_i}.h>

static void test_{i}(int a, int b) {{
  foo_{header_i}(b, a);
}}

    """.strip()


def get_header_template(i: int) -> str:
    function_declaration = f"void foo_{i}(int a, int b);\n" * NUMBER_OF_LINES_IN_HEADER

    return f"""
#pragma once

// Some function
{function_declaration}

    """.strip()


def generate_sources(progress: ProgressReporter):
    os.makedirs(SOURCES_DIR)
    all_sources = []
    for i in range(NUMBER_OF_SOURCES):
        subdir = SOURCES_DIR / get_source_subdir(i)
        os.makedirs(subdir, exist_ok=True)
        source_path = subdir / f"file_{i}.cpp"
        with open(source_path, "w") as source:
            source.write(get_source_template(i))
            all_sources.append(source_path)

            progress.report(f"Generated {i} of {NUMBER_OF_SOURCES} sources")

    return all_sources


def generate_headers(progress: ProgressReporter):
    os.makedirs(INCLUDES_DIR)
    all_include_dirs = set()
    for i in range(NUMBER_OF_HEADERS):
        subdir = INCLUDES_DIR / get_include_subdir(i)

        os.makedirs(subdir, exist_ok=True)

        all_include_dirs.add(subdir)

        with open(subdir / f"file_{i}.h", "w") as header:
            header.write(get_header_template(i))

            progress.report(f"Generated {i} of {NUMBER_OF_HEADERS} headers")

    return sorted(all_include_dirs)


def generate_compile_commands(sources: list[pathlib.Path], headers: list[pathlib.Path], progress: ProgressReporter):
    include_flags = [f"-I{include_dir.relative_to(PROJECT_DIR).as_posix()}" for include_dir in sorted(headers)]

    with open(PROJECT_DIR / f'compile_commands.json', 'w') as file:
        compile_commands = []
        for i, source in enumerate(sources):
            command = [COMPILER_PATH]

            if COMPILER_PATH.endswith("clang-cl.exe"):
                command += ["--driver-mode=cl"]
                command += ["/c"]
                command += [f"/Foobj/{source.relative_to(PROJECT_DIR).as_posix().removesuffix(".cpp")}.obj"]
                command += [f"/Fdobj/{source.relative_to(PROJECT_DIR).as_posix().removesuffix(".cpp")}.pdb"]
                command += include_flags
            else:
                command += ["-c", source.relative_to(PROJECT_DIR).as_posix()]
                command += include_flags

            compile_commands.append({
                "directory": PROJECT_DIR.absolute().as_posix(),
                "command": subprocess.list2cmdline(command),
                "file": source.relative_to(PROJECT_DIR).as_posix()
            })

            progress.report(f"Generated {i} of {len(sources)} compile commands")

        json.dump(compile_commands, file, indent=4)


def generate_cmake_lists(sources: list[pathlib.Path], headers: list[pathlib.Path], progress: ProgressReporter):
    with open(PROJECT_DIR / f'CMakeLists.txt', 'w') as file:
        file.write("#\n")
        file.write(f"# Generated with {" ".join(sys.argv)}\n")
        file.write("#\n")
        file.write("\n")

        file.write("cmake_minimum_required(VERSION 3.20)\n")
        file.write(f"project({PROJECT_NAME})\n")
        file.write(f"\n")
        file.write(f"set(CMAKE_CXX_STANDARD 20)\n")
        file.write("add_executable(my_exe)\n")
        file.write(f"\n")

        file.write("target_sources(my_exe PRIVATE\n")

        for i, source in enumerate(sources):
            file.write(f"    \"{source.relative_to(PROJECT_DIR).as_posix()}\"\n")

        file.write(")\n")
        file.write(f"\n")

        file.write("target_include_directories(my_exe PRIVATE\n")

        for i, header in enumerate(headers):
            file.write(f"    \"{header.relative_to(PROJECT_DIR).as_posix()}\"\n")

        file.write(")\n")
        file.write(f"\n")


def generate_project(progress: ProgressReporter):
    print(f"Generating project at {PROJECT_DIR.as_posix()}")

    try:
        if os.path.exists(PROJECT_DIR):
            print("Removing existing project")
            shutil.rmtree(PROJECT_DIR)

        os.makedirs(PROJECT_DIR, exist_ok=True)

        all_sources = generate_sources(progress)
        all_include_dirs = generate_headers(progress)

        if PROJECT_MODEL == 'compdb':
            generate_compile_commands(all_sources, all_include_dirs, progress)
        elif PROJECT_MODEL == 'cmake':
            generate_cmake_lists(all_sources, all_include_dirs, progress)
        else:
            assert False, "unreachable"
    except:
        print("Project generation failed, cleaning up...")
        shutil.rmtree(PROJECT_DIR, ignore_errors=True)
        raise


def main() -> int:
    progress = ProgressReporter()
    generate_project(progress)
    return 0


if __name__ == "__main__":
    sys.exit(main())

